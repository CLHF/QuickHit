import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JTextField;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/*
 * The unit class is essentially a container for all of the chains generated by a single unit in a given turn.
 */
public class Unit extends JPanel implements ChangeListener, ActionListener {
	private int numberOfCasts;
	private static ChainVisualizer chainVisualizer;
	private String unitName;
	private int slot;
	private int sendTime;			//This is the frame on which the unit will be tapped, sending them to execute their skills.
	private Skill[] skills = new Skill[Constants.MAX_CAST_COUNT];
	private ArrayList<Integer> hitFrames, castStartFrames;
	private JSlider unitSendTimeSlider;
	private JTextField unitNameField, sendTimeSliderText;

	Unit(int newSlotNumber) {
		sendTime = 0;
		slot = newSlotNumber;
		unitName = "Unit " + Integer.toString(slot + 1);
		hitFrames = null;
		castStartFrames = null;
		this.setLayout(new GridLayout(2 + Constants.MAX_NUMBER_OF_UNITS, 1 + Constants.MAX_CAST_COUNT));
		unitNameField = new JTextField("Unit " + Integer.toString(slot + 1));
		unitNameField.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				unitName = unitNameField.getText();
				chainVisualizer.updateChains();
			}
		});
		this.add(unitNameField);
		for(int count = 0; count < Constants.MAX_CAST_COUNT; count++) {
			skills[count] = new Skill(count+1, this);
			this.add(skills[count]);
		}
		unitSendTimeSlider = new JSlider(0, 200);
		unitSendTimeSlider.setValue(0);
		unitSendTimeSlider.setMajorTickSpacing(25);
		unitSendTimeSlider.setPaintTicks(true);
		unitSendTimeSlider.addChangeListener(this);
		sendTimeSliderText = new JTextField("0", 3);
		sendTimeSliderText.setHorizontalAlignment(JTextField.CENTER);
		sendTimeSliderText.addActionListener(this);
		this.add(unitSendTimeSlider);
		this.add(sendTimeSliderText);
	}

	/*
	 * Combines the hit frames from all of a unit's skills that are used in a given turn. 
	 */
	public void calcFrames() {
		hitFrames = new ArrayList<Integer>();
		castStartFrames = new ArrayList<Integer>();
		calcNumberOfCasts();
		int currentCastFrame = sendTime;
		int currentHitFrame = sendTime;
		for(int count = 0; count < numberOfCasts; count++) {
			if(skills[count].getHits() != null) {
				currentHitFrame = currentCastFrame + skills[count].getOffset() + skills[count].getCGDelay();
				for(int iterations = 0; iterations < skills[count].getHits().length; iterations++) {
					currentHitFrame += skills[count].getHits()[iterations];
					hitFrames.add(currentHitFrame);
				}
			}
			castStartFrames.add(currentCastFrame);
			currentCastFrame += skills[count].getOffset() + skills[count].getCGDelay() + skills[count].getCastTime();
		}
		Collections.sort(hitFrames);
		chainVisualizer.updateChains();
	}
	
	/*
	 * Calculates how many casts a unit is using this turn. Note that it stops as soon as it sees a single "None" skill-- any "non-damaging" skills must be input as custom skills without frames.
	 */
	private void calcNumberOfCasts() {
		numberOfCasts = 0;
		for(int count = 0; count < skills.length; count++) {
			if((skills[count].getCastTime() != null) && (skills[count].getHits() != null)) {
				numberOfCasts++;
			}
		}
	}
	
	/*
	 * Accessor method for skills.
	 */
	public Skill[] getSkills() {
		return skills;
	}
	
	/*
	 * Accessor method for numberOfCasts.
	 */
	public int getNumberOfCasts() {
		return numberOfCasts;
	}
	
	/*
	 * Accessor method for sendTime.
	 */
	public int getSendTime() {
		return sendTime;
	}
	
	/*
	 * Accessor method for hitFrames.
	 */
	public ArrayList<Integer> getHitFrames() {
		return hitFrames;
	}
	
	/*
	 * Accessor method for unitName.
	 */
	public String getUnitName() {
		return unitName;
	}
	
	public static ChainVisualizer getChainVisualizer() {
		return chainVisualizer;
	}
	
	/*
	 * Accessor method for castStartFrames.
	 */
	public ArrayList<Integer> getCastStartFrames() {
		return castStartFrames;
	}
	
	/*
	 * Sets the chainVisualizer so that it can be updated whenever the skills or units change.
	 */
	public static void setChainVisualizer(ChainVisualizer newChainVisualizer) {
		chainVisualizer = newChainVisualizer;
	}

	/*
	 * Handles UI input from the send time slider.
	 */
	@Override
	public void stateChanged(ChangeEvent e) {
		sendTime = unitSendTimeSlider.getValue();
		sendTimeSliderText.setText(Integer.toString(sendTime));
		calcFrames();
	}

	/*
	 * Handles the UI input from the text box under the send time slider.
	 */
	@Override
	public void actionPerformed(ActionEvent e) {
		if(sendTimeSliderText.getText().equals("")) {
			sendTimeSliderText.setText("0");
		}
		sendTime = Integer.parseInt(sendTimeSliderText.getText());
		if(sendTime < unitSendTimeSlider.getMinimum()) {
			unitSendTimeSlider.setValue(unitSendTimeSlider.getMinimum());
		}
		else if (sendTime > unitSendTimeSlider.getMaximum()) {
			int newSendTime = sendTime;
			unitSendTimeSlider.setMaximum(newSendTime);
			unitSendTimeSlider.setValue(newSendTime);
			sendTime = newSendTime;
		}
		else {
			unitSendTimeSlider.setValue(sendTime);
		}
	}
}